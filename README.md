# SnappetChallenge submission

This is my submission for the [SnappetChallenge](https://github.com/Teun/SnappetChallenge). Due to time constraints I haven't been able to actually properly apply knockout (or angular, or ember), but a lot of other ideas and practices should be in here somewhere. Time was sparse and I've focused mostly on the backend :-).

### How to get it up and running

* Open the solution in VS2013 or VS2015
* Run the Snappet.Challenge.Web project
* ???
* Profit

Note: Visual Studio occasionally refuses to copy dependencies to the web/bin folder. If the web project throws an exception, build the SnappetChallenge.Infrastructure.DependencyResolution project and retry.

Sqlite is embedded as database so it should be able to run standalone. You may need to update nuget to view packages.

### Frameworks and tools used

* MVC5 
* Web API
* EF6
* Sqlite (embedded)
* Ninject
* Bower 
* jQuery
* bootstrap
* chartjs

### Abstracting the EF DbContext

Is it really useful to abstract the DbContext into a generic context and subsequently the dbsets into repositories? Probably not. I mostly did it here for the sake of discussion (and to show that I understand abstraction):

* EF is already an abstraction of your database, so you abstract the abstraction (DbContext is a unit of work and DbSet is a repository)
* Do you really want to be able to swap out your ORM? Not very likely
* Abstracting EF away will probably make you lose functionality
* If you abstract EF away but still expose IQueryable, the abstraction is leaky. IQueryable is very Linq specific, but abstracting IQueryable is nearly impossible.
* An interface should explicitly define a contract, but generics make the contract less explicit and more vague

Other notes:

* Repositories in this solution do expose IQueryable but they are wrapped by a service layer in order to keep querying logic out of presentation
* Instead of repositories, the service layer could use query/command objects 

### Thoughts and musings on architecture

The backend architecture is largely based on [The Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/), once coined by Jeffrey Palermo. It's typically a domain driven architecture that relies heavily on dependency inversion. What I like about this architecture is that it focuses on the core part, which consists of your actual domain and services (or at least the definitions). That's the part where you add value to business. The outer parts (such as your DAL or ui) are usually commodities. Everybody has a data access layer, it's not central to this architecture. It's just a way to implement your domain.

A big advantage is that coupling is pretty straightforward, it is all towards the center of the onion. It basically means that the core has no dependencies and can be built independently. The outer parts implement the inner parts. I think it's an improvement over the typical n-tier architecture (ui -> BLL -> DAL).

### Miscellaneous

* An embedded sqlite database resides in the app_data folder of the mvc project. It was generated by the parser tool in the tools solution folder
* Contexts aren't disposed explicitly. Should probably be handled by the DI container with correct scoping, but haven't gotten around to it
* For the sake of brevity there is no shared layout, just the single dashboard page